{"name": "test_login_correct_username_correct_password", "status": "broken", "statusDetails": {"message": "requests.exceptions.ChunkedEncodingError: (\"Connection broken: ConnectionAbortedError(10053, 'An established connection was aborted by the software in your host machine', None, 10053, None)\", ConnectionAbortedError(10053, 'An established connection was aborted by the software in your host machine', None, 10053, None))", "trace": "self = <urllib3.response.HTTPResponse object at 0x000001BC0FC17C70>\n\n    @contextmanager\n    def _error_catcher(self) -> typing.Generator[None]:\n        \"\"\"\n        Catch low-level python exceptions, instead re-raising urllib3\n        variants, so that low-level exceptions are not leaked in the\n        high-level api.\n    \n        On exit, release the connection back to the pool.\n        \"\"\"\n        clean_exit = False\n    \n        try:\n            try:\n>               yield\n\nvenv\\Lib\\site-packages\\urllib3\\response.py:754: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nvenv\\Lib\\site-packages\\urllib3\\response.py:879: in _raw_read\n    data = self._fp_read(amt, read1=read1) if not fp_closed else b\"\"\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nvenv\\Lib\\site-packages\\urllib3\\response.py:862: in _fp_read\n    return self._fp.read(amt) if amt is not None else self._fp.read()\n           ^^^^^^^^^^^^^^^^^^\n..\\..\\AppData\\Local\\Python\\pythoncore-3.14-64\\Lib\\http\\client.py:484: in read\n    s = self.fp.read(amt)\n        ^^^^^^^^^^^^^^^^^\n..\\..\\AppData\\Local\\Python\\pythoncore-3.14-64\\Lib\\socket.py:725: in readinto\n    return self._sock.recv_into(b)\n           ^^^^^^^^^^^^^^^^^^^^^^^\n..\\..\\AppData\\Local\\Python\\pythoncore-3.14-64\\Lib\\ssl.py:1304: in recv_into\n    return self.read(nbytes, buffer)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <ssl.SSLSocket [closed] fd=-1, family=23, type=1, proto=0>, len = 127478\nbuffer = <memory at 0x000001BC0FBDD0C0>\n\n    def read(self, len=1024, buffer=None):\n        \"\"\"Read up to LEN bytes and return them.\n        Return zero-length string on EOF.\"\"\"\n    \n        self._checkClosed()\n        if self._sslobj is None:\n            raise ValueError(\"Read on closed or unwrapped SSL socket.\")\n        try:\n            if buffer is not None:\n>               return self._sslobj.read(len, buffer)\n                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nE               ConnectionAbortedError: [WinError 10053] An established connection was aborted by the software in your host machine\n\n..\\..\\AppData\\Local\\Python\\pythoncore-3.14-64\\Lib\\ssl.py:1138: ConnectionAbortedError\n\nThe above exception was the direct cause of the following exception:\n\n    def generate():\n        # Special case for urllib3.\n        if hasattr(self.raw, \"stream\"):\n            try:\n>               yield from self.raw.stream(chunk_size, decode_content=True)\n\nvenv\\Lib\\site-packages\\requests\\models.py:820: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nvenv\\Lib\\site-packages\\urllib3\\response.py:1066: in stream\n    data = self.read(amt=amt, decode_content=decode_content)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nvenv\\Lib\\site-packages\\urllib3\\response.py:955: in read\n    data = self._raw_read(amt)\n           ^^^^^^^^^^^^^^^^^^^\nvenv\\Lib\\site-packages\\urllib3\\response.py:878: in _raw_read\n    with self._error_catcher():\n         ^^^^^^^^^^^^^^^^^^^^^\n..\\..\\AppData\\Local\\Python\\pythoncore-3.14-64\\Lib\\contextlib.py:162: in __exit__\n    self.gen.throw(value)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <urllib3.response.HTTPResponse object at 0x000001BC0FC17C70>\n\n    @contextmanager\n    def _error_catcher(self) -> typing.Generator[None]:\n        \"\"\"\n        Catch low-level python exceptions, instead re-raising urllib3\n        variants, so that low-level exceptions are not leaked in the\n        high-level api.\n    \n        On exit, release the connection back to the pool.\n        \"\"\"\n        clean_exit = False\n    \n        try:\n            try:\n                yield\n    \n            except SocketTimeout as e:\n                # FIXME: Ideally we'd like to include the url in the ReadTimeoutError but\n                # there is yet no clean way to get at it from this context.\n                raise ReadTimeoutError(self._pool, None, \"Read timed out.\") from e  # type: ignore[arg-type]\n    \n            except BaseSSLError as e:\n                # FIXME: Is there a better way to differentiate between SSLErrors?\n                if \"read operation timed out\" not in str(e):\n                    # SSL errors related to framing/MAC get wrapped and reraised here\n                    raise SSLError(e) from e\n    \n                raise ReadTimeoutError(self._pool, None, \"Read timed out.\") from e  # type: ignore[arg-type]\n    \n            except IncompleteRead as e:\n                if (\n                    e.expected is not None\n                    and e.partial is not None\n                    and e.expected == -e.partial\n                ):\n                    arg = \"Response may not contain content.\"\n                else:\n                    arg = f\"Connection broken: {e!r}\"\n                raise ProtocolError(arg, e) from e\n    \n            except (HTTPException, OSError) as e:\n>               raise ProtocolError(f\"Connection broken: {e!r}\", e) from e\nE               urllib3.exceptions.ProtocolError: (\"Connection broken: ConnectionAbortedError(10053, 'An established connection was aborted by the software in your host machine', None, 10053, None)\", ConnectionAbortedError(10053, 'An established connection was aborted by the software in your host machine', None, 10053, None))\n\nvenv\\Lib\\site-packages\\urllib3\\response.py:781: ProtocolError\n\nDuring handling of the above exception, another exception occurred:\n\n    @pytest.fixture(scope=\"session\")\n    def driver():\n        browser = config[\"browser\"].strip().lower()\n        if browser == \"chrome\":\n>           service = ChromeService(ChromeDriverManager().install())\n                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nconftest.py:66: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nvenv\\Lib\\site-packages\\webdriver_manager\\chrome.py:40: in install\n    driver_path = self._get_driver_binary_path(self.driver)\n                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nvenv\\Lib\\site-packages\\webdriver_manager\\core\\manager.py:40: in _get_driver_binary_path\n    file = self._download_manager.download_file(driver.get_driver_download_url(os_type))\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nvenv\\Lib\\site-packages\\webdriver_manager\\core\\download_manager.py:32: in download_file\n    return File(response, file_name)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^\nvenv\\Lib\\site-packages\\webdriver_manager\\core\\file_manager.py:12: in __init__\n    self.content = stream.content\n                   ^^^^^^^^^^^^^^\nvenv\\Lib\\site-packages\\requests\\models.py:902: in content\n    self._content = b\"\".join(self.iter_content(CONTENT_CHUNK_SIZE)) or b\"\"\n                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\n    def generate():\n        # Special case for urllib3.\n        if hasattr(self.raw, \"stream\"):\n            try:\n                yield from self.raw.stream(chunk_size, decode_content=True)\n            except ProtocolError as e:\n>               raise ChunkedEncodingError(e)\nE               requests.exceptions.ChunkedEncodingError: (\"Connection broken: ConnectionAbortedError(10053, 'An established connection was aborted by the software in your host machine', None, 10053, None)\", ConnectionAbortedError(10053, 'An established connection was aborted by the software in your host machine', None, 10053, None))\n\nvenv\\Lib\\site-packages\\requests\\models.py:822: ChunkedEncodingError"}, "description": "Test login with correct username and correct password.", "start": 1767367822761, "stop": 1767367822761, "uuid": "eb64b221-2ca5-434e-9b1b-e28606ce68ea", "historyId": "73be65653c7801c1b3e9ad3c4844d02f", "testCaseId": "73be65653c7801c1b3e9ad3c4844d02f", "fullName": "tests.test_login#test_login_correct_username_correct_password", "labels": [{"name": "parentSuite", "value": "tests"}, {"name": "suite", "value": "test_login"}, {"name": "host", "value": "OTSI-Lap080"}, {"name": "thread", "value": "15472-MainThread"}, {"name": "framework", "value": "pytest"}, {"name": "language", "value": "cpython3"}, {"name": "package", "value": "tests.test_login"}]}